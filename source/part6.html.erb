---
  title: Osa 6
  exercise_page: true
  quiz_page: false
  published: true
---


<% partial 'partials/hint', locals: { name: 'Kuudennen osan oppimistavoitteet' } do %>


  <p>
    Osaa tehdä yhteenvetokyselyitä SQL-kielellä. Osaa selvittää miten tietokannanhallintajärjestelmä hakee annetun SQL-kyselyn tuloksen. Tietää mitä indeksit ovat ja tietää milloin tietokantatauluun tulee määritellä indeksejä. Tuntee käsitteet tietokannan eheys ja tietokantatransaktio, ja tietää tilanteita milloin transaktioita kannattaa käyttää. Tietää tietokannanhallintajärjestelmältä vaadittuja ominaisuuksia, joita tarvitaan tietokantatransaktioiden toimintaan. Tuntee CAP-teoreeman ja tietää GDPR-lainsäädännön olemassaolon sekä ainakin muutamia siihen liittyviä säännöksiä. 
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Yhteenvetokyselyt SQL-kielellä
<% end %>

<p>
  Harjoittelemamme SQL-kyselyt ovat tähän mennessä tuottaneet listauksia tietokantataulujen sisällöistä. Listauksia tuottavat kyselyt ovat erittäin hyödyllisiä, kun halutaan vastata esimerkiksi kysymyksiin kuten "Listaa kaikki opiskelijat, jotka ovat osallistuneet kurssille tietokantojen perusteet" tai "Listaa kaikki kurssit, joille annettu opiskelija on ilmoittautunut". Kysymykset kuten "Kuinka moni opiskelija on osallistunut kurssille tietokantojen perusteet" ovat kuitenkin vaatineet manuaalista työtä, sillä kyselyn tulosrivit on pitänyt laskea käsin tai jonkun toisen ohjelman avulla.
</p>

<p>
  SQL-kieli tarjoaa välineitä yhteenvetokyselyiden tekemiseen. Tällaisia kyselyitä ovat esimerkiksi juurikin yllä mainittu "kuinka moni" -- eli tulosrivien määrä -- sekä esimerkiksi erilaiset summa- ja keskiarvokyselyt. Käytännössä yhteenvetokyselyt tehdään SQL-kielen tarjoamien funktioiden avulla, jotka muuntavat tulosrivit toiseen muotoon. Alla on listattuna muutamia tyypillisimpiä funktioita, joita tietokantakyselyissä käytetään.
</p>

<table class="table">
  
  <tr>
    <th>
      Tavoite
    </th>
    <th>
      Funktio
    </th>
    <th>
      Esimerkki
    </th>
  </tr>

  <tr>
    <td>
      Rivien lukumäärän selvittäminen
    </td>
    <td>
      <code>COUNT</code>
    </td>
    <td>
      <% partial 'partials/sql_highlight' do %>
SELECT COUNT(*) FROM <em>Taulu</em>
      <% end %>
    </td>
  </tr>

  <tr>
    <td>
      Numeerisen sarakkeen keskiarvon laskeminen
    </td>
    <td>
      <code>AVG</code>
    </td>
    <td>
      <% partial 'partials/sql_highlight' do %>
SELECT AVG(<em>sarake</em>) FROM <em>Taulu</em>
      <% end %>
    </td>
  </tr>

  <tr>
    <td>
      Numeerisen sarakkeen summan laskeminen
    </td>
    <td>
      <code>SUM</code>
    </td>
    <td>
      <% partial 'partials/sql_highlight' do %>
SELECT SUM(<em>sarake</em>) FROM <em>Taulu</em>
      <% end %>
    </td>
  </tr>

  <tr>
    <td>
      Numeerisen sarakkeen minimiarvon selvittäminen
    </td>
    <td>
      <code>MIN</code>
    </td>
    <td>
      <% partial 'partials/sql_highlight' do %>
SELECT MIN(<em>sarake</em>) FROM <em>Taulu</em>
      <% end %>
    </td>
  </tr>
  
  <tr>
    <td>
      Numeerisen sarakkeen maksimiarvon selvittäminen
    </td>
    <td>
      <code>MAX</code>
    </td>
    <td>
      <% partial 'partials/sql_highlight' do %>
SELECT MAX(<em>sarake</em>) FROM <em>Taulu</em>
      <% end %>
    </td>
  </tr>

</table>


<p>
  Tarkastellaan näitä kyselyitä hieman tarkemmin. Oletetaan, että käytössämme on seuraava lentomatkoja kuvaava tietokantataulu.
</p>


<table class="table">
  <tr>
    <th colspan="4">
      Lentomatka(yhtio, lahtopaikka, maaranpaa, pituus)
    </th>
  </tr>
  <tr>
    <th>
      Lentoyhtiö
    </th>
    <th>
      Lähtöpaikka
    </th>
    <th>
      Määränpää
    </th>
    <th>
      Lennon pituus (minuuttia)
    </th>
  </tr>
  <tr>
    <td>
      Air Berlin
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Berliini
    </td>
    <td>
      205
    </td>
  </tr>
  <tr>
    <td>
      Finnair
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Oulu
    </td>
    <td>
      70
    </td>
  </tr>
  <tr>
    <td>
      Finnair
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Berliini
    </td>
    <td>
      200
    </td>
  </tr>
  <tr>
    <td>
      Finnair
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Tukholma
    </td>
    <td>
      50
    </td>
  </tr>
  <tr>
    <td>
      Finnair
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Mallorca
    </td>
    <td>
      230
    </td>
  </tr>
  <tr>
    <td>
      Norwegian
    </td>
    <td>
      Helsinki
    </td>
    <td>
      Mallorca
    </td>
    <td>
      240
    </td>
  </tr>
</table>

<p>
  Yhteenvetokyselyiden avulla saamme selville erilaisia tilastoja. Alla muutamia esimerkkejä:
</p>

<ul>
  <li>
    Kuinka monta matkaa tietokantataulussa Lentomatka on yhteensä?
    <% partial 'partials/sql_highlight' do %>
      SELECT COUNT(*) FROM Lentomatka
    <% end %>
  </li>

  <li>
    Kuinka monta lentoyhtiötä on tietokantataulussa lentomatka? (Huomaa avainsanan DISTINCT käyttö)
    <% partial 'partials/sql_highlight' do %>
      SELECT COUNT(DISTINCT yhtio) FROM Lentomatka
    <% end %>
  </li>  
  
  <li>
    Kuinka monta lentoa taulussa on Helsingistä Mallorcalle?
    <% partial 'partials/sql_highlight' do %>
      SELECT COUNT(*) FROM Lentomatka
          WHERE lahtopaikka = 'Helsinki' AND maaranpaa = 'Mallorca'
    <% end %>
  </li>

  <li>
    Mikä on keskimääräinen Finnairin lennon pituus?
    <% partial 'partials/sql_highlight' do %>
      SELECT AVG(pituus) FROM Lentomatka
          WHERE yhtio = 'Finnair'
    <% end %>
  </li>

  <li>
    Mikä on lyhin matkan kesto Helsingistä Berliiniin?
    <% partial 'partials/sql_highlight' do %>
      SELECT MIN(pituus) FROM Lentomatka
          WHERE lahtopaikka = 'Helsinki' AND maaranpaa = 'Berliini'
    <% end %>
  </li>

</ul>

<p>
  Yllä olevat esimerkit tuottavat tulokseksi aina yhden luvun. Entä jos haluaisimme saada selville yhtiökohtaisia tietoja kuten vaikkapa jokaisen yhtiön lyhimmän lennon? Tarkastellaan tätä seuraavaksi.
</p>


<% partial 'partials/exercise', locals: { name: 'Yhteenvetokyselyt, osa 1' } do %>

  
  <p>
    Tehtäväpohjan kansiossa <code>db</code> tulee tiedosto nimeltä <code>Chinook_Sqlite.sqlite</code>. Käytimme samaa tiedostoa myös yhdessä osan 3 tehtävistä. Tietokannassa on seuraavat taulut:
  </p>

  <pre>
  sqlite&gt; .tables
  Album          	Employee       	InvoiceLine    	PlaylistTrack
  Artist         	Genre          	MediaType      Track        
  Customer       	Invoice        	Playlist     
  </pre>

  <p>
    Tietokanta kuvaa digitaalisen musiikin myyntipalvelua. Tietokannan relaatiokaavio löytyy osoitteesta <a href="https://github.com/lerocha/chinook-database/wiki/Chinook-Schema" target="_blank" norel>https://github.com/lerocha/chinook-database/wiki/Chinook-Schema</a>. Kirjoita SQLiten avulla kyselyt, joilla saa selville seuraavat tiedot.
  </p>

  
  <ul>
    <li>Kysely 1: Kuinka monta albumia (Album) tietokannassa on yhteensä?</li>
    <li>Kysely 2: Minkä on kaikkien tietokannassa olevien laskujen (Invoice) hinnan (total) keskiarvo?</li>
    <li>Kysely 3: Kuinka monta 'Blues', 'Jazz' tai 'Metal'-genren kappaletta tietokannassa on yhteensä?</li>
  </ul>

  <p>
    Kun olet saanut kyselyt toimimaan, kopioi ne tehtäväpohjassa olevan luokan Kyselyja metodeihin kysely1, kysely2 ja kysely3. Metodeihin tulee siis kopioida SQL-kieliset kyselyt, joilla em. kysymyksiin saa vastaukset, ei kyselyiden vastauksia. 
  </p>


<% end %>

<% partial 'partials/material_sub_heading' do %>
  Tulosten ryhmittely
<% end %>


<p>
  Tulosten ryhmittely tietyn sarakkeen perusteella tapahtuu komennon <code>GROUP BY</code> perustella. Komento <code>GROUP BY</code> lisätään taulujen listauksen ja mahdollisten kyselyn rajausehtojen jälkeen. Komentoa <code>GROUP BY</code> seuraa sarake, jonka perusteella tulokset ryhmitellään. Jotta ryhmittelystä tulee mielekäs, asetetaan ryhmittelyn peruste tyypillisesti myös SELECT-komentoa seuraavaan sarakelistaukseen.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT <em>ryhmittelysarake</em>, <em>FUNKTIO</em>(<em>sarake</em>) FROM <em>Taulu</em>
      GROUP BY <em>ryhmittelysarake</em>
<% end %>


<p>
  Alla muutamia esimerkkejä:
</p>

<ul>
  
  <li>
    Kuinka monta matkaa kullakin lentoyhtiöllä on tarjolla?
    <% partial 'partials/sql_highlight' do %>
      SELECT yhtio, COUNT(*) FROM Lentomatka GROUP BY yhtio
    <% end %>
  </li>

  <li>
    Kuinka monta alle 100 minuutin pituista lentomatkaa eri kaupungeista lähtee?
    <% partial 'partials/sql_highlight' do %>
      SELECT lahtopaikka, COUNT(*) FROM Lentomatka
          WHERE pituus &lt; 100 GROUP BY lahtopaikka
    <% end %>
  </li>

  <li>
    Kuinka pitkiä kunkin lentoyhtiön matkat ovat keskimäärin?
    <% partial 'partials/sql_highlight' do %>
      SELECT yhtio, AVG(pituus) FROM Lentomatka GROUP BY yhtio
    <% end %>
  </li>
  
</ul>


<p>
  Taulujen yhdistäminen toimii kuten ennen. Valittavat taulut kerrotaan joko FROM -avainsanan jälkeen tai JOIN -avainsanan jälkeen, riippuen tavasta, jolla yhdistäminen tehdään. Ryhmittelykomento tulee mahdollisten WHERE-ehtojen jälkeen.
</p>

<p>
  Oletetaan seuraavat taulut Kurssi ja Kurssitehtävä.
</p>


<ul>
  <li>
    Kurssi((pk) id, nimi, opintopisteet)
  </li>
  <li>
    Kurssitehtava((pk) id, (fk) kurssi_id -&gt; Kurssi, tehtava)
  </li>
</ul>

<p>
  Kurssikohtaisten tehtävien lukumäärän laskeminen onnistuu seuraavasti. Avainsana AS muuntaa tuloksena saatavassa taulussa olevan sarakkeen nimen.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT Kurssi.nimi AS kurssi, COUNT(*) AS tehtäviä FROM Kurssi, Kurssitehtävä
      WHERE Kurssi.id = Kurssitehtava.kurssi_id
      GROUP BY Kurssi.nimi
<% end %>


<p>
  Edellä kuvatun kyselyn tuloksia tarkastellessa huomaamme, että tuloksissa ei ole yhtäkään tehtävätöntä kurssia. Tämä selittyy kyselyillämme -- olemme valinneet mukaan vain rivit, joilla hakuehdot täyttyvät. Kirjoitetaan edellinen kysely siten, että otamme huomioon kurssit vaikka niihin ei liittyisikään yhtäkään toisen taulun riviä -- käytämme siis <code>LEFT JOIN</code>-liitosoperaatiota.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT Kurssi.nimi AS kurssi, COUNT(Kurssitehtava.id) AS tehtäviä FROM Kurssi
      LEFT JOIN Kurssitehtävä ON Kurssi.id = Kurssitehtava.kurssi_id
      GROUP BY Kurssi.nimi
<% end %>

<p>
  Edellä COUNT-funktiolle annetaan parametrina kurssitehtävän id. Jos funktiolle annetaan parametrina *, myös NULL-arvo -- eli tyhjä arvo -- lasketaan (ainakin joissain tietokannanhallintajärjestelmissä).
</p>


<% partial 'partials/material_sub_heading' do %>
  Ryhmittely useamman sarakkeen perusteella
<% end %>


<p>
  Komennolle <code>GROUP BY</code> voi antaa myös useampia sarakkeita, jolloin ryhmittely tapahtuu sarakeryhmittäin. Esimerkiksi ryhmittely <code>GROUP BY kurssi, arvosana</code> ryhmittelisi taulussa olevat rivit ensin kurssin perusteella, jonka jälkeen kurssikohtaiset ryhmät ryhmiteltäisiin vielä arvosanan perusteella. Tällöin jokaiselle kurssille tulisi erilliset arvosanaryhmät.
</p>

<p>
  Oletetaan edellä kuvatun taulun lisäksi taulut Kurssisuoritus ja Opiskelija:
</p>

<ul>
  <li>
    Kurssisuoritus((pk) id, (fk) kurssi_id -&gt; Kurssi, opiskelija_id -&gt; Opiskelija, arvosana, paivamaara)
  </li>
  <li>
    Opiskelija((pk) id, opiskelijanumero, nimi, syntymävuosi)
  </li>
</ul>

<p>
  Kurssikohtaiset arvosanaryhmät saa selville seuraavalla kyselyllä.
</p>


<% partial 'partials/sql_highlight' do %>
  SELECT Kurssi.nimi AS kurssi, Kurssisuoritus.arvosana AS arvosana, COUNT (*) AS lukumäärä
      FROM Kurssi, Kurssisuoritus
      WHERE Kurssi.id = Kurssisuoritus.kurssi_id
      GROUP BY Kurssi.nimi, Kurssisuoritus.arvosana
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Tulosten järjestäminen
<% end %>

<p>
  Kyselyn tulokset voi järjestää komennolla <code>ORDER BY</code>, jota seuraa järjestettävät sarakkeet. Sarakkeelle voi antaa myös lisämääreen <code>ASC</code> (<em>ascending</em>), joka kertoo että tulokset tulee järjestää nousevaan järjestykseen, ja <code>DESC</code> (<em>descending</em>), joka kertoo että tulokset tulee järjestää laskevaan järjestykseen. Oletuksena järjestys on nouseva.
</p>

<p>
  Komento <code>ORDER BY</code> tulee kyselyn loppuun. Edellisen kurssiarvosanatilaston tulokset saisi kurssin nimen perusteella järjestykseen seuraavasti.
</p>


<% partial 'partials/sql_highlight' do %>
  SELECT Kurssi.nimi AS kurssi, Kurssisuoritus.arvosana AS arvosana, COUNT (*) AS lukumäärä
      FROM Kurssi, Kurssisuoritus
      WHERE Kurssi.id = Kurssisuoritus.kurssi_id
      GROUP BY Kurssi.nimi, Kurssisuoritus.arvosana
      ORDER BY Kurssi.nimi
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Hakutulosten rajaaminen yhteenvetokyselyissä
<% end %>

<p>
  Yhteenvetokyselyissä laskettavat tulokset kuten summa, rivien lukumäärä ja keskiarvo muodostetaan vasta, kun kaikki kyselyn rivit on selvillä. Kyselyiden tuloksen rajaamiseen käytetty WHERE toimii siten, että se tarkastelee tuloksia riveittäin -- se ei osaa odottaa summan laskemisen lopputulosta.
</p>

<p>
  Jos yhteenvetokyselyn tuloksen perusteella halutaan rajata tuloksia, tulee käyttää <code>HAVING</code>-ehtoa. HAVING ehto tarkastetaan vasta, kun yhteenvetokyselyn tulokset ovat selvillä. Ehto HAVING lisätään ryhmittelykyselyn jälkeen esimerkiksi seuraavalla tavalla.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT Kurssi.nimi AS kurssi, AVG(Kurssisuoritus.arvosana) keskiarvo
      FROM Kurssi, Kurssisuoritus
      WHERE Kurssi.id = Kurssisuoritus.kurssi_id
      GROUP BY Kurssi.nimi
      HAVING keskiarvo &lt; 2
      ORDER BY Kurssi.nimi
<% end %>

<p>
  Yllä olevalla kyselyllä saadaan selville ne kurssit, joihin liittyvien kurssisuoritusten keskiarvo on alle 2. 
</p>

<p>
  Kuten esimerkissä näkyy, samassa kyselyssä voi olla sekä <code>WHERE</code>-ehto että <code>HAVING</code>-ehto.
</p>


<% partial 'partials/exercise', locals: { name: 'Yhteenvetokyselyt, osa 2' } do %>

  <p>
    Jatketaan edellisestä tehtävästä tutun tietokannan parissa..
  </p>
  
  <p>
    Tehtäväpohjan kansiossa <code>db</code> tulee tiedosto nimeltä <code>Chinook_Sqlite.sqlite</code>. Tietokannassa on seuraavat taulut:
  </p>

  <pre>
  sqlite&gt; .tables
  Album          	Employee       	InvoiceLine    	PlaylistTrack
  Artist         	Genre          	MediaType      Track        
  Customer       	Invoice        	Playlist     
  </pre>

  <p>
    Tietokanta kuvaa digitaalisen musiikin myyntipalvelua. Tietokannan relaatiokaavio löytyy osoitteesta <a href="https://github.com/lerocha/chinook-database/wiki/Chinook-Schema" target="_blank" norel>https://github.com/lerocha/chinook-database/wiki/Chinook-Schema</a>. Kirjoita SQLiten avulla kyselyt, joilla saa selville seuraavat tiedot.
  </p>

  
  <ul>
    <li>Kysely 1: Kuinka monta kappaletta kuhunkin genreen liittyy? Tuloksessa tulee olla kaksi saraketta, joista toisen nimi on <code>genre</code> ja toisen nimi on <code>kappaleita</code>.</li>
    <li>Kysely 2: Kuinka monta kappaletta kustakin genrestä on ostettu? Voit olettaa, että kappale on ostettu jos lasku on olemassa. Tuloksessa tulee olla kaksi saraketta, joista toisen nimi on <code>genre</code> ja toisen nimi on <code>ostettuja</code>.</li>
    <li>Kysely 3: Kuinka monella levyllä kukin artisti esiintyy? Tuloksessa tulee olla kaksi saraketta, joista toisen nimi on <code>artisti</code> ja toisen nimi on <code>levyt</code>.</li>
  </ul>

  <p>
    Kun olet saanut kyselyt toimimaan, kopioi ne tehtäväpohjassa olevan luokan Kyselyja metodeihin kysely1, kysely2 ja kysely3. Metodeihin tulee kopioida SQL-kieliset kyselyt, joilla em. kysymyksiin saa vastaukset, ei siis vastauksia.
  </p>

  <p>
    <em>
      Huom! Tehtävässä on tilanteita, missä yhteenvetokyselyn tuloksessa esiintyvä lukumäärä (esim. kappaleet, ostetut, levyt) voi olla 0.
    </em>
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Alikyselyt
<% end %>

<p>
  Alikyselyt ovat nimensä mukaan kyselyn osana suoritettavia alikyselyitä, joiden tuloksia käytetään osana pääkyselyä. Pohditaan kysymystä <em>Miten haen opiskelijat, jotka eivät ole vielä osallistuneet yhdellekään kurssille?</em>, ja käytetään siihen ensin aiemmin tutuksi tullutta tapaa, eli LEFT JOIN -kyselyä. Yhdistetään opiskelijaa ja kurssisuoritusta kuvaavat taulut LEFT JOIN-kyselyllä siten, että myös opiskelijat, joilla ei ole suorituksia tulevat mukaan vastaukseen. Tämän jälkeen, jätetään vastaukseen vain ne rivit, joilla kurssisuoritukseen liittyvät tiedot ovat tyhjiä -- tämä onnistuu katsomalla mitä tahansa kurssisuoritus-taulun saraketta, ja tarkistamalla onko se tyhjä, eli <em>null</em>. Tämä onnistuu seuraavasti:
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT opiskelijanumero FROM Opiskelija
      LEFT JOIN Kurssisuoritus
      ON Opiskelija.id = Kurssisuoritus.opiskelija_id
      WHERE Kurssisuoritus.kurssi_id IS null
<% end %>

<p>
  Toinen vaihtoehto edellisen kyselyn toteuttamiseen on luoda kysely, joka hakee kaikki ne opiskelijat, jotka eivät ole kurssisuorituksia saaneiden opiskelijoiden joukossa. Tässä on oleellisesti kaksi kyselyä: (1) hae niiden opiskelijoiden tunnus, joilla on kurssisuoritus, ja (2) hae opiskelijat, jotka eivät ole edellisen kyselyn palauttamassa joukossa.
</p>

<p>
  Ensimmäinen kysely on suoraviivainen.
</p>


<% partial 'partials/sql_highlight' do %>
  SELECT opiskelija_id FROM Kurssisuoritus
<% end %>

<p>
  Toinenkin kysely on melko suoraviivainen -- avainsanalla NOT IN voidaan rajata joukkoa.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT * FROM Opiskelija
      WHERE id NOT IN (<em>ensimmainen kysely</em>)
<% end %>

<p>
  Yhdessä kyselyt ovat siis muotoa:
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT * FROM Opiskelija
      WHERE id NOT IN (
          SELECT opiskelija_id FROM Kurssisuoritus
      )
<% end %>

<p>
  Käytännössä alikyselyt tuottavat kyselyn tuloksena taulun, josta pääkyselyssä tehtävä kysely tehdään. Ylläolevassa esimerkissä alikyselyn tuottamassa taulussa on vain yksi sarake, jossa on kurssisuorituksen saaneiden opiskelijoiden opiskelijanumerot.
</p>

<p>
  Määreen <code>NOT IN</code>, joka tarkastaa että valitut arvot eivät ole alikyselyn tuottamassa taulussa, lisäksi käytössä on määre <code>IN</code>. Määreen <code>IN</code> avulla voidaan luoda ehto, jolla tarkastetaan, että valitut arvot ovat annetussa joukossa tai taulussa. Esimerkiksi alla haetaan kaikki kurssisuoritukset, joissa arvosana on kolme tai viisi.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT * FROM Kurssisuoritus WHERE arvosana IN (3, 5)
<% end %>

<p>
  Määreiden IN ja NOT IN lisäksi alikyselyissä voidaan käyttää määreitä EXISTS ja NOT EXISTS, joiden avulla voidaan rajata hakujoukkoa alikyselyssä olevan ehdon perusteella. Voimme esimerkiksi kirjoittaa aiemmin kirjoitetun kursseja suorittamattomia opiskelijoita etsivän kyselyn siten, että jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla tarkistetaan, että sitä ei löydy taulusta Kurssisuoritus.
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT opiskelijanumero FROM Opiskelija
      WHERE NOT EXISTS (
          SELECT opiskelija_id FROM Kurssisuoritus
          WHERE Kurssisuoritus.opiskelija_id = Opiskelija.id
      )
<% end %>

<p>
  Edellä oleva kysely tarkistaa jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla ettei sitä löydy Kurssisuoritus-taulun opiskelija-sarakkeesta. Käytännössä -- jos tietokantamoottori ei optimoi kyselyä -- jokainen opiskelija-taulun rivi aiheuttaa uuden kyselyn kurssisuoritus-tauluun, mikä tekee kyselystä tehottoman.
</p>

<% partial 'partials/hint', locals: { name: 'Kyselyn tulos on taulu' } do %>

  <p>
    Jokainen SQL-kysely tuottaa tuloksena taulun. Taulussa voi olla tasan yksi sarake ja rivi, tai vaikkapa tuhansia rivejä ja kymmeniä sarakkeita. Silloinkin, kun suoritamme yksinkertaisen haun, kuten vaikkapa "Hae kaikki kurssilla 'Tietokantojen perusteet' olevat opiskelijat", on haun tuloksena taulu.
  </p>

  <p>
    Kaikki tekemämme SQL-kyselyt ovat liittyneet tauluihin. Emmekö siis voisi tehdä kyselyjä myös vastauksiin? Vastaus on kyllä.
  </p>

  <p>
    Esimerkiksi vanhimman (tai vanhimmat, jos tämä ei ole yksikäsitteistä) opiskelijan löytää -- muunmuassa -- etsimällä kaikista pienimmän mahdollisimman syntymävuoden (kyselyn tulos on taulu), jonka jälkeen vastaustaulussa olevaa tulosta verrataan kaikkien opiskelijoiden syntymävuosiin.
  </p>

  <% partial 'partials/sql_highlight' do %>
    SELECT * FROM Opiskelija
        WHERE syntymävuosi
        IN (SELECT MIN(syntymavuosi) FROM Opiskelija)
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Tietokantakyselyiden tehokkuudesta
<% end %>

<p>
  Tietokantaan tehtävä SQL-kielinen kysely voidaan suorittaa useammalla eri tavalla. Kyselyn suoritus voi käydä läpi tietokantataulun jokaisen rivin, se voi tarkastella vain rajattua osaa tietokantataulun riveistä, tai suoritus voi olla useamman taulun tapauksessa jonkinlainen yhdistelmä edellisiä. Kyselystrategia perustuu tietokannanhallintajärjestelmän sisäisen kyselynoptimoijan sekä tietokantatauluihin määriteltyjen ominaisuuksien kuten indeksien perusteella.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tietokantakyselyn tarkastelu
<% end %>

<p>
  Tietokantakyselyiden suoritusstrategiaa voi tarkastella tietokannanhallintajärjestelmäkohtaisen apukyselyn avulla. SQLitessä kyselyn sisältöön pääsee kommennolla <code>EXPLAIN QUERY PLAN</code>, jota seuraa konkreettinen kysely. Suoritusstrategia sisältää tiedon läpikäytävistä tietokannoista sekä kyselyn muodosta. Kyselyn muoto on joko "SCAN" tai "SEARCH". Muoto SCAN käy koko tietokantataulun läpi ja SEARCH tarkastelee tietokantatauluun liittyvää indeksiä.
</p>

<p>
  Tarkastellaan tätä konkreettisen esimerkin kautta. Oletetaan, että käytössämme on tietokanta, jossa on seuraavat tietokantataulut.
</p>

<% partial 'partials/sql_highlight' do %>
  CREATE TABLE Asiakas (
      id integer PRIMARY KEY,
      nimi varchar(200),
      puhelinnumero varchar(20),
      katuosoite varchar(50),
      postinumero integer,
      postitoimipaikka varchar(20)
  );
<% end %>

<% partial 'partials/sql_highlight' do %>
  CREATE TABLE Tilaus (
      id integer PRIMARY KEY,
      asiakas_id integer,
      aika date,
      kuljetustapa varchar(40),
      vastaanotettu boolean,
      toimitettu boolean,
      FOREIGN KEY (asiakas_id) REFERENCES Asiakas(id)
  );
<% end %>

<p>
  Jos haluamme listata asiakkaiden nimet ja puhelinnumerot, teemme kyselyn "SELECT nimi, puhelinnumero FROM Asiakas". Strategia on selvä -- käydään koko tietokantataulu läpi. Ensimmäisessä esimerkissä kytketään lisäksi SQLiten otsikot päälle ja vaihdetaan tulostusmuotoa kolumnimuotoon. Alla olevissa esimerkeissä on lisäksi käytetty .width -komentoa tulostuksen leveyden sovittamiseksi.
</p>

<% partial 'partials/sample_output' do %>
sqlite> .headers on
sqlite> .mode column
sqlite> EXPLAIN QUERY PLAN SELECT nimi, puhelinnumero FROM Asiakas;
selectid order from detail                                                                      
-------- ----- ---- ------------------
0        0     0    SCAN TABLE Asiakas                                                          
<% end %>


<p>
  Vastaava strategia liittyy myös tietyn nimisen asiakkaan etsimiseen. Alla kuvatussa esimerkissä tarkastellaan kyselyä, missä etsitään Cobb-nimistä asiakasta.
</p>

<% partial 'partials/sample_output' do %>
  sqlite> EXPLAIN QUERY PLAN SELECT nimi, puhelinnumero
              FROM Asiakas WHERE nimi = 'Cobb';
  selectid order from  detail            
  -------- ----- ----  ------------------
  0        0     0     SCAN TABLE Asiakas
<% end %>

<p>
  Myös Tilaus-taulun tietojen listaaminen vaatii koko tietokantataulun läpikäynnin. Alla listataan tilaukset, jotka on jo toimitettu.
</p>


<% partial 'partials/sample_output' do %>
  sqlite> EXPLAIN QUERY PLAN SELECT * FROM Tilaus
              WHERE toimitettu = 1;
  selectid order from detail           
  -------- ----- ---- -----------------
  0        0     0    SCAN TABLE Tilaus
<% end %>

<p>
  Tarkastellaan seuraavaksi hieman monimutkaisempaa kyselyä, missä tulostetaan niiden asiakkaiden nimet, jotka ovat tehneet vähintään yhden tilauksen.
</p>


<% partial 'partials/sample_output' do %>
sqlite> EXPLAIN QUERY PLAN SELECT nimi, puhelinnumero
            FROM Asiakas JOIN Tilaus
                ON Asiakas.id = Tilaus.asiakas_id;
selectid order from detail                                                  
-------- ----- ---- --------------------------------------------------------
0        0     1    SCAN TABLE Tilaus                                       
0        1     0    SEARCH TABLE Asiakas USING INTEGER PRIMARY KEY (rowid=?)
<% end %>

<p>
  Kysely onkin nyt erilainen. Kyselyssä käydään ensin läpi koko taulu Tilaus, jonka jälkeen etsitään tietokantataulusta Asiakas rivejä asiakas-taulun pääavaimen perusteella. Entä jos tietokantataulu Asiakas olisikin määritelty siten, että kenttä <code>id</code> ei olisi pääavain?
</p>

<% partial 'partials/sql_highlight' do %>
  CREATE TABLE Asiakas (
      id integer,
      nimi varchar(200),
      puhelinnumero varchar(20),
      katuosoite varchar(50),
      postinumero integer,
      postitoimipaikka varchar(20)
  );
<% end %>

<% partial 'partials/sample_output' do %>
sqlite> EXPLAIN QUERY PLAN SELECT nimi, puhelinnumero
            FROM Asiakas JOIN Tilaus
                ON Asiakas.id = Tilaus.asiakas_id;
selectid order from detail                                                           
-------- ----- ---- -----------------------------------------------------------------
0        0     0    SCAN TABLE Asiakas                                               
0        1     1    SEARCH TABLE Tilaus USING AUTOMATIC COVERING INDEX (asiakas_id=?)
<% end %>

<p>
  Tietokannanhallintajärjestelmä vaihtaa läpikäytävien taulujen järjestystä. Nyt kysely käy ensin läpi koko Asiakas-taulun, ja etsii tämän jälkeen Tilaus-taulusta tietoa automaattisesti luodun indeksin perusteella.
</p>

<% partial 'partials/material_sub_heading' do %>
  Indeksit eli hakua nopeuttavat tietorakenteet
<% end %>

<p>
  Indeksit ovat tietokantatauluista erillisiä yhden tai useamman sarakkeen tiedoista koostuvia tietorakenteita, jotka viittaavat tietokantataulun riveihin. Indeksirakenteita on useita erilaisia, mm. hajautustaulut ja puurakenteet. Indeksien tavoite on käytännössä -- tietokantojen yhteydessä -- tietokantakyselyiden nopeuttaminen.
</p>

<p>
  <em>
    Indeksiä voi ajatella perinteikkään kirjaston korttiluettelona. Kirjaston tiskille mentäessä ja tiettyä kirjaa kysyttäessä, kirjastovirkailija käy läpi kirjan nimen perusteella aakkostettuja kortteja. Koska nimet ovat aakkosjärjestyksessä, jokaista korttia ei tarvitse tarkastella tiettyä kirjaa etsittäessä. Kortissa on tieto kirjan konkreettisesta paikasta kirjastossa -- kun kortti löytyy, kirjan voi hakea. Jos kirjan nimen sijaan kirjaa etsitään kirjoittajan perusteella, tulee käyttää toista korttipakkaa, joka sisältää kirjoittajien nimet sekä mahdollisesti myös tiedon kirjojen nimistä. Jos kirjaa etsitään sisällön perusteella joudutaan huonolla tuurilla käymään jokainen fyysinen kirjaston kirja läpi.
  </em>
</p>

<p>
  Pohditaan tilannetta, missä miljardi riviä sisältävän taulun tiettyyn sarakkeeseen on määritelty indeksi. Oletetaan, että indeksi sisältää arvot järjestettynä. Tällöin, tiettyä arvoa haettaessa, voimme aloittaa keskimmäisestä arvosta -- jos haettava arvo on pienempi, tutkitaan "vasemmalla" olevaa puolikasta. Jos taas haettava arvo on suurempi, tutkitaan "oikealla" olevaa puolikasta. Alueen rajaaminen jatkuu niin pitkään, kunnes haettava arvo löytyy, tai rajaus päätyy tilanteeseen, missä tutkittavia arvoja ei enää ole. Tämä menetelmä -- <em>puolitushaku</em> tai <em>binäärihaku</em> lienee tuttu ohjelmointikursseilta.
</p>

<p>
  Jos rivejä on yhteensä miljardi, voidaan ne jakaa kahteen osaan noin log<sub>2</sub> 1 000 000 000 kertaa, eli noin 30 kertaa. Jos oletamme, että arvoa ei löydy taulusta, tulee yhteensä tarkastella siis noin 30 riviä miljardin sijaan.
</p>

<p>
  Indeksin määrittely tietokantataulun sarakkeelle tapahtuu tietokantataulun luomisen jälkeen komennolla <code>CREATE INDEX</code>, jota seuraa uuden indeksin nimi, avainsana <code>ON</code>, sekä taulu ja taulun sarakkeet, joille indeksi luodaan. Tietokannanhallintajärjestelmä luo tietokantataulun pääavaimelle ja viiteavaimille indeksit tyypillisesti automaattisesti.
</p>

<p>
  Oletetaan, että sovelluksessamme asiakkaita haetaan usein nimen perusteella. Luodaan edellä kuvattuun Asiakas-taulun sarakkeelle nimi indeksi.
</p>

<% partial 'partials/sample_output' do %>
  sqlite> CREATE INDEX idx_asiakas_nimi ON Asiakas (nimi);
<% end %>

<p>
  Tarkastellaan aiemmin tehtyä Cobb-nimisen henkilön hakua uudelleen.
</p>

<% partial 'partials/sample_output' do %>
  sqlite> EXPLAIN QUERY PLAN SELECT nimi, puhelinnumero FROM Asiakas
              WHERE nimi = 'Cobb';
  selectid order from detail                                                    
  -------- ----- ---- ----------------------------------------------------------
  0        0     0    SEARCH TABLE Asiakas USING INDEX idx_asiakas_nimi (nimi=?)
<% end %>

<p>
  Strategia muuttuu edellisestä. Aiemmin tietokannanhallintajärjestelmän strategia on ollut koko tietokantataulun Asiakas läpikäynti, nyt tietoa haetaan indeksistä. Jos käytössä oleva indeksi olisi esimerkiksi hajautustaulu, tapahtuisi haku vakioajassa -- eli "tarkasteluja" tehtäisiin "yksi" riippumatta tietomäärästä -- <em>tietorakenteisiin, niihin tehtäviin hakuihin sekä niiden tehokkuuksiin tutustutaan tarkemmin kurssilla tietorakenteet ja algoritmit.</em>
</p>

<p>
  Taulut ja sarakkeet, joihin indeksejä kannattaa harkita, liittyvät paljon suoritettuihin (ja hitaahkoihin) tietokantakyselyihin. Ensimmäiset askeleet liittyvät (1) tietokantataulujen pää- ja viiteavainten indeksien luomiseen, (2) hakuehtoihin liittyvien sarakkeiden indeksien luomiseen sekä (3) järjestysehtoihin liittyvien sarakkeiden indeksien lumiseen. Alla on kuvattuna eräs suoraviivainen prosessi tietokantataulun indeksien päättämiselle: lähtökohtana on kysely.
</p>

<figure>
  <img src="/img/indeksit-saanto.png" alt="alku=>start: Alku
				    join=>condition: Käsitelläänkö 
				    useampia
				    tauluja?
				    where=>condition: Kyselyssä
				    rajausehtoja?
				    loppu=>end: Loppu
				    avaimet=>operation: Luo taulujen pääavaimille
				    ja viiteavaimille indeksit
				    rajaus=>operation: Luo indeksit rajausehdossa
				    esiintyville sarakkeille.
				    jarjestys=>condition: Järjestetäänkö 
				    tuloksia?
				    jarj=>operation: Luo indeksit 
				    järjestettäville sarakkeille.
				    alku->join
				    join(yes,right)->avaimet->where
				    join(no)->where
				    where(yes,right)->rajaus->jarjestys
				    where(no)->jarjestys
				    jarjestys(no)->loppu
				    jarjestys(yes,right)->jarj->loppu" />
</figure>


<p>
  Indeksin luominen tietokantataululle luo tietorakenteen, jota käytetään tiedon hakemiseen. Jokaista indeksiä tulee päivittää myös tietokantaa muokkaavien operaatioiden yhteydessä, jotta indeksin tiedot ovat ajan tasalla. Käytännössä liiallinen indeksien luominen saattaa myös hidastaa sovelluksen toimintaa.
</p>

  
<% partial 'partials/material_sub_heading' do %>
  Välimuistit sovelluksissa
<% end %>

<p>
  Kun tietokantaa käytetään osana annettua sovellusta (esimerkiksi web-sovellusta), sovelluksen vastuulla on tietokantakyselyiden tekeminen tietokannanhallintajärjestelmään. Jos sovellus on ainoa tietokannan käyttäjä (tietokantaa ei muokata muista järjestelmistä), ja jos merkittävä osa kyselyistä on toistuvia hakukyselyjä, voi sovellukseen rakentaa tietokannan toimintaa abstrahoiva välimuisti.
</p>

<p>
  Välimuistissa on käytännössä kyse käsiteltävän tiedon tuomisesta lähemmäksi käyttäjää. Tietokantaa käyttävien sovellusten tapauksessa usein haettava tieto tuodaan sovelluksen muistiin, jolloin sovelluksen ei tarvitse hakea tietoa erikseen tietokannasta. Välimuisti tyhjennetään aina tietokannan päivityksen yhteydessä, jolloin käyttäjälle päätyvä tieto on aina ajan tasalla.
</p>

<p>
  Yksinkertaisimmillaan välimuistitoteutus voi olla olemassaolevan Dao-toteutuksen kapselointi erilliseen Dao-toteutukseen. Oletetaan, että käytössämme on kolmannelta viikolta tuttu vaillinainen AsiakasDao-toteutus. Välimuistillisen toteutuksen luominen on melko suoraviivaista -- alla toteutuksessa muistetaan vain yksittäiset asiakkaat.
</p>



<% partial 'partials/code_highlight' do %>
  import java.util.*;
  import java.sql.*;

  public class CachedAsiakasDao extends AsiakasDao implements Dao&lt;Asiakas, Integer&gt; {

      private HashMap&lt;Integer, Asiakas&gt; asiakkaatAvaimilla;
  
      public CachedAsiakasDao(Database database) {
          super(database);
          this.asiakkaatAvaimilla = new HashMap&lt;&gt;();
      }

      @Override
      public Asiakas findOne(Integer key) throws SQLException {
          if (!asiakkaatAvaimilla.containsKey(key)) {
              Asiakas asiakas = super.findOne(key);
              asiakkaatAvaimilla.put(key, asiakas);
          }

          return asiakkaatAvaimilla.get(key);
      }

      @Override
      public Asiakas saveOrUpdate(Asiakas object) throws SQLException {
          Asiakas asiakas = super.saveOrUpdate(object);
          asiakkaatAvaimilla.put(asiakas.getId(), asiakas);
          return asiakas;
      }
  
      @Override
      public void delete(Integer key) throws SQLException {
          this.asiakkaatAvaimilla.removeKey(key);
          return super.delete(key);
      }
  }
<% end %>

<p>
  Jos asiakkaiden tietohin liittyvistä tietokantakyselyistä 99% on hakuoperaatioita, on merkittävässä osassa tapauksia tieto valmiiksi sovelluksen käytössä, jolloin tietokantaan ei tarvitse ottaa yhteyttä. Toisaalta, jos sovellus on sellainen, että merkittävä osa käsittelystä sisältää myös tietokannassa olevan tiedon muokkausoperaatioita, ei edellä kuvatusta välimuistista ole juurikaan hyötyä.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tietokannan denormalisointi
<% end %>

<p>
  Tietokannan normalisointi johtaa tyypillisesti tilanteeseen, missä tietokannassa on useita tietokantatauluja, joista jokainen kuvaa jotain selkeää käsitettä. Tietokantataulujen väliset yhteydet tunnistetaan pää- ja viiteavainten avulla, ja taulujen attribuutit ovat selkeitä. Tietokannasta puuttuu toisteinen tieto.
</p>

<p>
  Yleisesti ottaen yllä kuvattu tilanne on hyvä, mutta absoluuttinen hyvyys liittyy paljolti myös käyttötarkoitukseen. Esimerkiksi raportointiin tarkoitettujen järjestelmien ei kannata todennäköisesti -- jos raportin luonti on hidas operaatio -- luoda samoja raportteja yhä uudelleen ja uudelleen, vaan voi olla mielekästä luoda erillinen tietokantataulu (tai muutama), jotka sisältävät raporteille oleelliset tiedot valmiiksi laskettuna.
</p>

<p>
  Myös tietokannan (tai tietokantataulun) käyttötarkoitus vaikuttaa normalisoinnin tarpeeseen. Esimerkiksi sivukäyntien kirjaamiseen tarkoitettu logitusjärjestelmä toimii tehokkaammin jos sivukäyntien tallentamiseen tarkoitetut osat järjestelmästä on denormalisoitu. Tarkastellaan tätä seuraavan esimerkin kautta.
</p>

<p>
  Alla on annettuna kaksi tietokantaa, toinen on normalisoitu ja toinen denormalisoitu. Kumpaakin käytetään järjestelmässä kävijöiden tekemien tapahtumien kirjaamiseen.
</p>

<p>
  Alla olevassa versiossa käyttäjä ja sivu on eriytetty omaksi käsitteekseen, johon tapahtuma-taulu viittaa. Kun tapahtumaa luodaan, tulee tapahtuman lisäämisen yhteydessä hakea käyttäjän tunnus taulusta Kayttaja sekä osoitetta vastaavan sivun tunnus taulusta Sivu.
</p>


<ul>
  <li>
    Kayttaja ((pk) id, kayttajatunnus)
  </li>
  <li>
    Sivu ((pk) id, osoite)
  </li>
  <li>
    Tapahtuma ((pk) id, (fk) kayttaja_id -&gt; Kayttaja, (fk) sivu_id -&gt; Sivu, aika, operaatio, ip, laite)
  </li>
</ul>

<p>
  Toinen vaihtoehto on tallentaa käyttäjätunnus ja sivun osoite sellaisenaan.
</p>

<ul>
  <li>
    Tapahtuma ((pk) id, kayttajatunnus, osoite, aika, operaatio, ip, laite)
  </li>
</ul>




<% partial 'partials/exercise', locals: { name: 'Operaatioiden tehokkuuden tarkastelu' } do %>

  <p>
    Luo SQLiten avulla tehtäväpohjan kansioon <code>db</code> kaksi yllä kuvattua tietokantaa. Ensimmäisen nimeksi tulee 'tapahtumat-normalisoitu.db' ja toisen nimeksi 'tapahtumat-denormalisoitu.db'. Tee tämän jälkeen ohjelma, joka testaa tiedon lisäämisen nopeutta edellä mainittuihin tietokantatauluihin. Luokan <code>OperaatioidenTehokkuus</code> <code>main</code>-metodin kutsun tulee lisätä 100 tapahtumaa kumpaankin tietokantaan.
  </p>

  <p>
    Ota seuraava CREATE TABLE-lause lähtökohdaksi.
  </p>

  <pre>
    CREATE TABLE Tapahtuma (
        id integer PRIMARY KEY, 
        kayttajatunnus varchar(255), 
        osoite varchar(255), 
        aika integer, 
        operaatio varchar(255), 
        ip varchar(255), 
        laite varchar(255)
    );
  </pre>

  <p>
    Voit olettaa, että järjestelmä saa jokaisen tapahtuman yhteydessä tietoonsa käyttäjätunnuksen, osoitteen, ajan, tehdyn operaation, ip-osoitteen sekä käyttäjän käyttämän laitteen. Tehtäväpohjassa on valmis toiminnallisuus satunnaisen tiedon luomiseen sekä paikat lisäyskyselyiden tekemiseen.
  </p>

  <p>
    Kun tietoa lisätään normalisoituun tietokantaan, tapahtuman lisäämisen yhteydessä tulee hakea käyttäjätaulusta tieto käyttäjästä (ja tallentaa käyttäjä tauluun jos kyseistä käyttäjää ei vielä ole), jonka lisäksi sivutaulusta tulee hakea tieto sivusta osoitteen perusteella (sekä lisätä sivu jos sitä ei vielä ole).
  </p>

  <p>
    Kun tietoa lisätään denormalisoituun tietokantaan, riittää tiedon tallentaminen tietokantatauluun.
  </p>

<% end %>


<% partial 'partials/hint', locals: { name: 'Normalisoida vai eikö normalisoida?' } do %>

  <p>
    Lue CodingHorror.com-blogista kirjoitus <a href="http://blog.codinghorror.com/maybe-normalizing-isnt-normal/" target="_blank">Maybe Normalizing Isn't Normal</a>.
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Tietokannan eheys ja transaktiot
<% end %>

<p>
  Eheydellä viitataan tallennetun tiedon oikeellisuuteen. Tietokannanhallintajärjestelmä ylläpitää tietokannan eheyttä jatkuvasti. Esimerkiksi sarakkeen, joka on määritelty sisältämään vain numeerista tietoa, ei pitäisi sisältää tekstimuotoista tietoa. Vastaavasti viiteavainten tulee viitata aina olemassaolevaan tietoon. 
</p>

<p>
  Eheyden ylläpitämisen sekä kohta tutuksi tulevien tietokantatransaktioiden ymmärtämiseksi on hyvä tuntea tietokannan toimintaa sovellustasolla. Kurssin ensimmäisessä osassa tarkasteltiin tiedon käsittelyä tiedostoissa -- tietokanta käyttää kiintolevyä tiedon tallentamiseen, mutta rivien käsittely tapahtuu (keskus)muistissa. Kun riviä halutaan päivittää, se haetaan ensin kovalevyltä muistiin, päivitetään ja viedään takaisin levylle.
</p>

<p>
  Keskusmuistin ongelma on se, että sen sisältö häviää esimerkiksi sähkökatkoksen sattuessa tai palvelimen kaatuessa. Havainnollistetaan ongelmallisuutta esimerkeillä:
</p>

<ul>
  <li>Annetaan kaikille yrityksen 1000000 kuukausipalkkaiselle työntekijälle 5% palkan korotus. <code>UPDATE Palkat SET kkpalkka = kkpalkka * 1,05</code> Mitä jos tietokantapalvelin kaatuu, kun vasta 10000 muutettua riviä on tallennettu levylle? 990000 vihaista työntekijää jää ilman palkankorotusta? Tarvitaan jokin keino varmistaa, että päivitys tehdään kokonaan tai ei lainkaan.</li>
  <li>Entä jos palkkojen maksuun liittyvä prosessi lukee palkkatietoja juuri samalla kun niitä ollaan päivittämässä? Lukuoperaatio voi lukea esimerkiksi vain tietyn toimipaikan työntekijöiden palkat - 100 riviä. Jos päivitys on yhtäaikaa kesken, voi käydä niin, että osaan luetuista riveistä on ehditty jo tehdä päivitys ja osaan ei. Nyt osa työntekijöistä saa syyskuun palkkansa korotettuna ja osa ei? Tarvitaan jokin keino hallita yhtäaikaisia prosesseja.</li>
</ul>


<% partial 'partials/material_sub_heading' do %>
  Tietokantatransaktiot
<% end %>

<p>
  Tietokantatransaktiot ratkaisevat edellä mainitut ongelmat. Ongelmat voidaan jakaa kahteen kategoriaan:
</p>
  
<ul>
  <li>Operaatioden keskeytymiset järjestelmän kaatuessa, häiriötilanteissa tai hallituissa keskeytyksissä</li>
  <li>Samanaikaset prosessit</li>
</ul>
  
<p>
  Tietokantatransaktio sisältää yhden tai useamman tietokantaan kohdistuvan operaation, jotka suoritetaan (järjestyksessä) kokonaisuutena. Jos yksikin operaatio epäonnistuu, kaikki operaatiot perutaan, ja tietokanta palautetaan tilaan, missä se oli ennen transaktion aloitusta. Klassinen esimerkki tietokantatransaktiosta on tilisiirto, missä nostetaan rahaa yhdeltä tililtä, ja siirretään rahaa toiselle tilille. Jos tilisiirron suoritus ei onnistu -- esimerkiksi rahan lisääminen toiselle tilille epäonnistuu -- tulee myös rahan nostaminen toiselta tililtä perua.
</p>

<p>
  Jokainen tietokantakysely suoritetaan omassa transaktiossaan, mutta, käyttäjä voi myös määritellä useamman kyselyn saman transaktion sisälle. Transaktio aloitetaan komennolla <code>BEGIN TRANSACTION</code>, jota seuraa kyselyt, ja lopulta komento <code>COMMIT</code>. Oletetaan, että käytössämme on taulu <code>Tili(id, saldo)</code>.
</p>

<% partial 'partials/sql_highlight' do %>
CREATE TABLE Tili (
    id integer PRIMARY KEY,
    saldo NOT NULL
);
<% end %>

<p>
  Tilisiirto kahden tilin välillä toteutetaan yhtenä transaktiona seuraavasti.
</p>

<% partial 'partials/sql_highlight' do %>
BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 2;
COMMIT;
<% end %>

<p>
  Ylläolevassa transaktiossa suoritetaan kaksi kyselyä, mutta tietokannan näkökulmasta toiminto on <em>atominen</em>, eli sitä ei voi pilkkoa osiin. Komennon <code>COMMIT</code> yhteydessä muutokset joko tallennetaan kokonaisuudessaan tietokantaan, tai tietokantaan ei tehdä minkäänlaisia muutoksia.
</p>

<p>
  Tietokantatransaktiota kirjoittaessa, ohjelmoija voi huomata tehneensä virheen. Tällöin suoritetaan komento <code>ROLLBACK</code>, joka peruu aloitetun transaktion aikana tehdyt muutokset. Suoritettua (<code>COMMIT</code>) tietokantatransaktiota ei voi perua.
</p>

<p>
  Alla esimerkki kahdesta tietokantatransaktiosta. Ensimmäinen perutaan, sillä siinä yritettiin vahingossa siirtää rahaa väärälle tilille. Toinen suoritetaan. Kokonaisuudessaan allaolevan kyselyn lopputulos on se, että tililtä 1 on otettu 10 rahayksikköä, ja tilille 2 on lisätty 10 rahayksikköä.
</p>

<% partial 'partials/sql_highlight' do %>
BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 3;
ROLLBACK;

BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 2;
COMMIT;
<% end %>

<p>
  Jokainen tietokantakysely -- myös "yhden rivin kyselyt" -- suoritetaan transaktion sisällä. Tietokannanhallintajärjestelmän vastuulla on vahtia, että transaktiot suoritetaan peräkkäin siten, että samaa tietoa ei voida käsitellä useammasta transaktiosta saman aikaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tietokantatransaktiot ja rajoitteet
<% end %>

<p>
  Koska tietokannanhallintajärjestelmä näkee transaktioiden sisällä suoritettavat käskyt atomisina, eli yksittäisenä kokonaisuutena, voivat tietokantatauluun määritellyt rajoitteet olla hetkellisesti rikki, kunhan ne transaktion suorituksen jälkeen ovat kunnossa.
</p>

<p>
  Esimerkiksi suomen kirjanpitosääntöjen mukaan jokaisessa yrityksessä tulee olla kaksinkertainen kirjanpito. Tässä jokaisen tilitapahtuman yhteydessä tulee merkitä sekä mistä raha on otettu (debit), että mihin raha on laitettu (credit). Tällaisessa järjestelmässä tulee olla (esimerkiksi) tietokantataulu <code>Kirjanpitotapahtuma</code>, johon muutokset merkitään.
</p>

<% partial 'partials/sql_highlight' do %>
CREATE TABLE Kirjanpitotapahtuma
(
    id integer PRIMARY KEY,
    paivamaara date NOT NULL,
    kirjanpitotili integer NOT NULL,
    kuvaus text NOT NULL,
    debit integer NOT NULL,
    credit integer NOT NULL,
    FOREIGN KEY(kirjanpitotili) REFERENCES Tili(id),
    CONSTRAINT kirjaus_tasmaa CHECK (SUM(debit) = SUM(credit))
)
<% end %>

<p>
  Nyt yhden transaktion sisällä voi tehdä useamman kirjanpitotapahtuman, kunhan transaktion suorituksen yhteydessä kirjanpitotapahtumien debit- ja credit-sarakkeiden summa täsmää. Yllä tietokantataulun luomiskomentoon on lisätty rajoite (<code>CONSTRAINT</code>), jonka avulla tietokantatauluun voidaan lisätä sääntöjä, joiden tulee olla aina transaktion jälkeen voimassa.
</p>

<% partial 'partials/exercise', locals: { name: 'Tietokantatransaktio' } do %>

  <p>
    Netti on täynnä hyviä oppaita. Osoitteessa <a href="http://www.sqlitetutorial.net/sqlite-java/transaction/" target="_blank">http://www.sqlitetutorial.net/sqlite-java/transaction/</a> on eräs tällainen. Tutustu oppaaseen.
  </p>

  <p>
    Luo tehtäväpohjaan oppaan kuvaama tiedosto <code>test.db</code> sekä ohjelma, jossa lisäät tietokantaan useamman rivin saman transaktion sisällä.
  </p>

  <p>
    <em>
      Tässä tehtävässä ei ole testejä. Palauta tehtävä se toimii toivotulla tavalla.
    </em>
  </p>  

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Tietokannanhallintajärjestelmän ominaisuuksia
<% end %>


<p>
  <strong>ACID</strong> (<strong>A</strong>tomicity, <strong>C</strong>onsistency, <strong>I</strong>solation, <strong>D</strong>urability) on joukko tietokannanhallintajärjestelmän ominaisuuksia:
</p>

<ul>

  <li>Atomisuudella (<code>Atomicity</code>) varmistetaan, että tietokantatransaktio suoritetaan joko kokonaisuudessaan tai ei lainkaan. Jos tietokannanhallintajärjestelmään tehtävät transaktiot eivät olisi atomisia, voisi esimerkiksi päivityskyselyistä päätyä tietokantaan asti vain osa -- tilisiirtoesimerkissä vain rahan ottaminen yhdeltä tililtä, mutta ei sen lisäämistä toiselle.</li>
    
  <li>Eheydellä (<code>Consistency</code>) varmistetaan, että tietokantaan määritellyt rajoitteet, kuten viiteavaimet, pätevät jokaisen transaktion jälkeen. Jos tietokanta ei mahdollistaisi eheystarkistusta, voisi esimerkiksi kirjanpito olla virheellinen.</li>
  
  <li>Eristyvyydellä (<code>Isolation</code>) varmistetaan, että transaktio (A) ei voi lukea toisen transaktion (B) muokkaamaa tietoa ennenkuin toinen transaktio (B) on suoritettu loppuun. Tällä varmistetaan se, että jos transaktioita suoritetaan rinnakkaisesti, kumpikin näkee tietokannan eheässä tilassa.</li>

  <li>Pysyvyydellä (<code>Durability</code>) varmistetaan, että transaktion suorituksessa tapahtuvat muutokset ovat pysyviä. Kun käyttäjä lisää tietoa tietokantaan, tietokannanhallintajärjestelmän tulee varmistaa että tieto säilyy myös virhetilanteissa (jos transaktion suoritus onnistuu).</li> 

</ul>

<p>
  Perinteiset tietokannanhallintajärjestelmät tarvitsevat atomisuuden ja pysyvyyden toteuttamiseen write-ahead-lokia (WAL). Se tarkoittaa sitä, että suoritettavaksi tuleva tietokantaoperaatio tallennetaan tekstimuotoisena lokina levylle ennen rivien varsinaista päivitystä. Tällöin operaatiot voidaan suorittaa uudelleen, jos tietokantapalvelin kaatuu ennen kuin muistissa päivitetyt rivit ehditään tallentaa levylle. Tämä nopeuttaa tietokannan toimintaa merkittävästi, sillä pitkien operaatioiden kirjoittamista levylle ei tarvitse odottaa ennen kuin sovellukselle voidaan vastata operaation onnistuneen. Eristyvyyden toteuttamiseen käytetään mm. erilaisia taulu- ja rivilukitusmekanismeja. Kurssilla <em>Transaktioiden hallinta</em> tutustutaan tarkemmin transaktioiden toimintaan.
</p>



<% partial 'partials/material_heading' do %>
  CAP-teoreema
<% end %>

<p>
  Merkittävä osa sovellusten toiminnallisuuden skaalaamisesta suuremmille käyttäjäjoukoille perustuu sovellusten toiminnallisuuden kopiointiin useammalle tietokoneelle eli palvelimelle. Kun sovellusta pyörittävä palvelin ei pysty enää vastaamaan kaikkiin sille tehtyihin pyyntöihin, hankitaan uusi palvelin, johon sovellus kopioidaan. Osa pyynnöistä ohjataan jatkossa tälle palvelimelle, jolloin palvelimet pystyvät yhdessä käsittelemään pyynnöt.
</p>

<p>
  Sovelluksen kopiointi useammalle palvelimelle aiheuttaa haasteita tiedon hallintaan ja oikeellisuuteen liittyen. Jos sovelluksen toteuttaja haluaa, että jokaisella sovelluksella oleva tieto on aina ajankohtaista ja että pyyntöön annettava vastaus on aina ajankohtainen palvelimesta riippumatta, tulee palvelinten kommunikoida ja päivittää tietoa keskenään. Pankit eivät esimerkiksi voi hyväksyä tilannetta, missä yhdellä palvelimella tilillä olisi rahaa ja yhdellä ei. 
</p>

<p>
  Tarkastellaan seuraavaksi lyhyesti CAP-teoreemaa. Sana CAP tulee termeistä Consistency, Availability, ja Partition tolerance.
</p>

<ul>
  <li>
    Consistency. Consistency viittaa järjestelmän ymmärrettävyyteen lineaarisesti toimivana prosessina. Mikäli järjestelmä toimii lineaarisesti (tai "Consistency" on olemassa), järjestelmän tulee aina palauttaa uusin mahdollinen tieto. Käytännössä jos järjestelmässä oleva prosessi B käynnistyy sen jälkeen kun prosessi A on suoritettu loppuun, ei prosessin B pitäisi koskaan nähdä tilaa, missä järjestelmä on ollut ennen prosessin A loppuun suorittamista. <em>Huom! CAP-teoreeman Consistency ei ole sama kuin ACID-termin Consistency (eristäytyneisyys). </em>
  </li>
  <li>
    Availability. Availability viittaa järjestelmän saatavuuteen. Jos järjestelmä on saatava (tai "Availability" on olemassa), jokaisen palvelimelle ohjautuvan pyynnön tulee palauttaa toivottu vastaus järkevän ajan puitteissa. Järjestelmässä ei siis saa olla tilannetta, missä palvelin on vastaamatta, vaikka sillä olisi siihen mahdollisuus.
  </li>
  <li>
    Partition tolerance. Partition tolerance viittaa siihen, että järjestelmän tulee toimia vaikka esimerkiksi palvelinkoneiden välinen yhteys olisi poissa käytöstä.
  </li>
</ul>

<p>
  CAP on <a href="https://en.wikipedia.org/wiki/Eric_Brewer_(scientist)" target="_blank">Eric Brewerin</a> ehdottama teoreema, jonka mukaan (useammalle tietokoneelle) hajautettu ohjelmisto voi saavuttaa samaan aikaan vain kaksi yllä olevasta kolmesta ominaisuudesta. 
</p>

<p>
  Todellisuudessa tilanne on kuitenkin se, että palvelut toimivat verkossa, joka ei ole koskaan täysin luotettava. Tämä tarkoittaa sitä, että skaalautuvaa järjestelmää suunnitteleva joutuu käytännössä tekemään kompromissin Consistencyn ja Availabilityn välillä. 
</p>

<p>
  Jos järjestelmä vaatii lineaarisen toiminnan (kuten esimerkiksi pankki), mutta järjestelmän toiminta tulee hajauttaa useammalle koneelle, tulee järjestelmän olla vastaamatta pyyntöihin virhetilanteissa -- järjestelmä ei voi olla aina saatavilla. Vastaavasti, jos järjestelmän tulee olla aina saatavilla (esimerkiksi sosiaalisen median palvelu) ja järjestelmän toiminta tulee hajauttaa useammalle koneelle, tulee järjestelmälle antaa mahdollisuus lähettää palvelun käyttäjille myös vanhentunutta tietoa.
</p>

<% partial 'partials/hint', locals: { name: 'BASE' } do %>

  <p>
    Tutustu myös Wikipedian artikkeliin <a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank">Eventual consistency</a>, mikä käsittelyy myös termiä BASE.
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  GDPR-lainsäädäntö
<% end %>

<p>
  Viimeistään toukokuussa 2018 kaikki Euroopan Unionissa toimivat organisaatiot joutuvat noudattamaan uutta GDPR-lakia, joka ohjeistaa henkilökohtaisten tietojen käsittelyyn liittyvää toimintaa. Alla säädöksen ydinkohdat:
</p>

<ul>

  <li>
    Henkilötietojen keräämiseen tulee kysyä lupa. Jotta henkilökohtaisia tietoja saa kerätä, henkilön tulee eksplisiittisesti ja tietoisesti sallia tietojen kerääminen. Suostumuksen tietojen keruun sallimiseen tulee olla aito, eli tietojen keruusta pitää pystyä kieltäytymään ilman negatiivisia seuraamuksia.
  </li>

  <li>
    Mitä tahansa ei saa kerätä. Kerättävien tietojen tulee olla perusteltavissa ja kerättävien tietojen tulee olla rajattu vain niihin, mitä organisaatio tarvitsee toimintaansa.
  </li>

  <li>
    Henkilötietojen poistaminen pitää olla mahdollista. Henkilön tulee pystyä pyytämään tietojen poistamista järjestelmästä, ja tiedot tulee poistaa jos organisaatiolla ei ole mitään laillista syytä tiedon säilyttämiseen. Organisaation tulee myös informoida kolmannen osapuolen organisaatioita, joille henkilökohtaisia tietoja on annettu.
  </li>

  <li>
    Tietoa ei saa "vuotaa". Lainsäädäntö mahdollistaa sakkojen antamisen kerätyn tiedon huonosta käsittelystä. Organisaatio voi saada jopa sakot, jonka koko on 4% organisaation vuotuisesta liikevaihdosta.
  </li>

  <li>
    Ei vain Euroopan Unionissa. Myös Euroopan Unionin ulkopuoliset organisaatiot, joiden kohdeyleisönä on Euroopan Unionin jäsenet, ovat lain piirissä.
  </li>
  
</ul>

<p>
  Tietojen käsittelyyn liittyviin oikeuksiin vaikuttaa myös käsittelijän tehtävä. Esimerkiksi Suomen koulutusjärjestelmällä on laillinen vastuu koulutuksen järjestämisestä -- omien koulutustietojen poistaminen ei todennäköisesti onnistu yliopiston rekisteristä, eikä yliopiston erikseen tule pyytää lupaa koulutustietojen tallentamiseen. Vastaavia poikkeuksia löytyy myös esimerkiksi tutkimukseen liittyen -- katso Anna Hännisen (OTM) video tietosuoja-asetuksesta sekä tieteellisestä tutkimuksesta.
</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/lDS_kp116vM?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

